package collections;import java.io.Serializable;import java.util.*;import java.util.function.BiPredicate;public class OneSideLinkedCycleList<Element> implements List<Element>, Serializable, Cloneable{    private Node    head;    private Integer size;    public OneSideLinkedCycleList( List<Element> list ){        size = list.size();        if( !list.isEmpty() ){            head = linkList( list );            lastNode.nextNode = head;        }    }    private OneSideLinkedCycleList( Node head , Integer size ){        this.head = head;        this.size = size;    }    private Node lastNode;    private Node linkList( List<Element> list ){        if( list.size() == 1 ){            lastNode = new Node( list.get( 0 ) , null );            return lastNode;        }        return new Node( list.get( 0 ) , linkList( list.subList( 1 , list.size() ) ) );    }    @Override    public int size(){        return size;    }    @Override    public boolean isEmpty(){        return size == 0;    }    @Override    public boolean contains( Object o ){        return indexOf( o ) != -1;    }    @Override    public Iterator<Element> iterator(){        return new Iterator<>(){            Node goingNode = head;            int goingIndex = 0;            @Override            public boolean hasNext(){                return goingIndex < size;            }            @Override            public Element next(){                Element element = goingNode.element;                goingNode = goingNode.nextNode;                goingIndex++;                return element;            }        };    }    @Override    public Object[] toArray(){        Object[] result = new Object[ size ];        int      i      = 0;        for( Element element : this ){ result[ i++ ] = element; }        return Arrays.copyOf( result , result.length );    }    @Override    public <T> T[] toArray( T[] result ){        if( result.length < size ){            result = ( T[] ) java.lang.reflect.Array.newInstance( result.getClass().getComponentType() , size );        }        int i = 0;        for( Element element : this ){ result[ i++ ] = ( T ) element; }        i++;        for( ; i < result.length ; i++ ){ result[ i ] = null; }        return Arrays.copyOf( result , result.length );    }    @Override    public boolean add( Element element ){        add( size , element );        return true;    }    @Override    public void clear(){        head = null;        size = 0;    }    private Node getNode( int offset ){        if( offset == -1 ){ return getNode( size - 1 ); }        checkRange( offset );        Node goingNode = head;        for( int i = 0 ; i < offset % size ; i++ , goingNode = goingNode.nextNode ){}        return goingNode;    }    private void checkRange( int index ){        if( isEmpty() ){ throw new IllegalStateException( "List is empty" ); }        if( !( 0 <= index ) ){ throw new IndexOutOfBoundsException(); }    }    @Override    public Element get( int index ){        return getNode( index ).element;    }    @Override    public Element set( int index , Element element ){        Node    node        = getNode( index );        Element prevElement = node.element;        node.element = element;        return prevElement;    }    @Override    public void add( int index , Element element ){        if( isEmpty() ){            head = new Node( element , null );            head.nextNode = head;        }else{            Node prev = getNode( index - 1 ), next = prev.nextNode;            prev.nextNode = new Node( element , next );        }        size++;    }    @Override    public Element remove( int index ){        checkRange( index );        Node    prev    = getNode( index - 1 ), removingNode = prev.nextNode, next = removingNode.nextNode;        Element element = removingNode.element;        prev.nextNode = next;        size--;        return element;    }    @Override    public int indexOf( Object o ){        int i = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ return i; }            i++;        }        return -1;    }    @Override    public int lastIndexOf( Object o ){        int i = -1, k = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ i = k; }            k++;        }        return i;    }    private class Node implements Serializable{        Element element;        Node nextNode;        Node( Element element , Node nextNode ){            this.element = element;            this.nextNode = nextNode;        }    }    @Override    public int hashCode(){        return Arrays.hashCode( this.toArray() );    }    @Override    public boolean equals( Object obj ){        if( !( obj instanceof OneSideLinkedCycleList ) ){ return false; }        OneSideLinkedCycleList list = ( OneSideLinkedCycleList ) obj;        return Arrays.equals( this.toArray() , list.toArray() );    }    @Override    public Object clone() throws CloneNotSupportedException{        OneSideLinkedCycleList<Element> clone = ( OneSideLinkedCycleList<Element> ) super.clone();        clone.size = size;        if( !isEmpty() ){            clone.head = clone.linkList( this );            clone.lastNode.nextNode = clone.head;        }        return clone;    }    @Override    public boolean remove( Object o ){        Node prev = getNode( -1 ), going = prev.nextNode;        for( int i = 0 ; i < size ; i++ , prev = going , going = going.nextNode ){            if( going.element == null ? o == null : going.element.equals( o ) ){                prev.nextNode = going.nextNode;                size--;                return true;            }        }        return false;    }    @Override    public boolean containsAll( Collection<?> collection ){        for( Object o : collection ){ if( !this.contains( o ) ){ return false; } }        return true;    }    @Override    public boolean addAll( Collection<? extends Element> collection ){        return addAll( size , collection );    }    @Override    public boolean addAll( int index , Collection<? extends Element> collection ){        if( collection.isEmpty() ){ return false; }        Node headOfAddingList = linkList( new ArrayList<>( collection ) );        Node prevNode         = getNode( index - 1 );        lastNode.nextNode = prevNode.nextNode;        prevNode.nextNode = headOfAddingList;        size += collection.size();        return true;    }    private boolean removeAllWithPredicate( BiPredicate<Element, Object> predicate , Collection<?> collection ){        Node    prev, going, next;        Boolean res = false;        for( Object o : collection ){            prev = getNode( -1 );            going = prev.nextNode;            next = going.nextNode;            for( int i = 0 ; i < size ; i++ , prev = going , going = next , next = next.nextNode ){                if( predicate.test( going.element , o ) ){                    res = true;                    prev.nextNode = next;                    going = next;                    next = next.nextNode;                    size--;                }            }        }        return res;    }    @Override    public boolean removeAll( Collection<?> collection ){        return removeAllWithPredicate( ( element , o ) -> element == null ? o == null : element.equals( o ) ,                                       collection );    }    @Override    public boolean retainAll( Collection<?> collection ){        return removeAllWithPredicate( ( element , o ) -> !element.equals( o ) , collection );    }    private Node listNodes( Node node , Integer count ){        if( count == 1 ){            lastNode = new Node( node.element , null );            return lastNode;        }        return new Node( node.element , listNodes( node.nextNode , count - 1 ) );    }    @Override    public List<Element> subList( int fromIndex , int toIndex ){        int size = toIndex - fromIndex;        if( size == 0 ){ return new OneSideLinkedCycleList<>( null , 0 ); }        Node head = listNodes( getNode( fromIndex ) , size );        lastNode.nextNode = head;        return new OneSideLinkedCycleList<>( head , size );    }    @Override    public ListIterator<Element> listIterator(){        return listIterator( 0 );    }    @Override    public ListIterator<Element> listIterator( int index ){        throw new UnsupportedOperationException();    }}