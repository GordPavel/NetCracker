package collections;import java.io.Serializable;import java.util.*;public class OneSideLinkedCycleList<Element> implements List<Element>, Serializable{    private Node    head;    private Integer size;    public OneSideLinkedCycleList( List<Element> list ){        size = list.size();        if( !list.isEmpty() ){            head = linkList( list );            lastNode.nextNode = head;        }    }    private Node lastNode;    private Node linkList( List<Element> list ){        if( list.size() == 1 ){            lastNode = new Node( list.get( 0 ) , null );            return lastNode;        }        return new Node( list.get( 0 ) , linkList( list.subList( 1 , list.size() ) ) );    }    @Override    public int size(){        return size;    }    @Override    public boolean isEmpty(){        return size == 0;    }    @Override    public boolean contains( Object o ){        return indexOf( o ) != -1;    }    @Override    public Iterator<Element> iterator(){        return new Iterator<>(){            Node goingNode = head;            int goingIndex = 0;            @Override            public boolean hasNext(){                return goingIndex < size;            }            @Override            public Element next(){                Element element = goingNode.element;                goingNode = goingNode.nextNode;                goingIndex++;                return element;            }        };    }    @Override    public Object[] toArray(){        Object[] result = new Object[ size ];        int      i      = 0;        for( Element element : this ){ result[ i++ ] = element; }        return result;    }    @Override    public <T> T[] toArray( T[] a ){        if( a.length < size ){            a = ( T[] ) java.lang.reflect.Array.newInstance( a.getClass().getComponentType() , size );        }        int i = 0;        for( Element element : this ){ a[ i++ ] = ( T ) element; }        i++;        for( ; i < a.length ; i++ ){ a[ i ] = null; }        return a;    }    @Override    public boolean add( Element element ){        add( size , element );        return true;    }    @Override    public void clear(){        head = null;        size = 0;    }    private Node getNode( int offset ){        if( offset == -1 ){ return getNode( size - 1 ); }        checkRange( offset );        Node goingNode = head;        for( int i = 0 ; i < offset % size ; i++ , goingNode = goingNode.nextNode ){}        return goingNode;    }    private void checkRange( int index ){        if( isEmpty() ){ throw new IllegalStateException( "List is empty" ); }        if( !( 0 <= index ) ){ throw new IndexOutOfBoundsException(); }    }    @Override    public Element get( int index ){        return getNode( index ).element;    }    @Override    public Element set( int index , Element element ){        Node    node        = getNode( index );        Element prevElement = node.element;        node.element = element;        return prevElement;    }    @Override    public void add( int index , Element element ){        if( isEmpty() ){            head = new Node( element , null );            head.nextNode = head;        }else{            Node prev = getNode( index - 1 ), next = prev.nextNode;            prev.nextNode = new Node( element , next );        }        size++;    }    @Override    public Element remove( int index ){        checkRange( index );        Node    prev    = getNode( index - 1 ), removingNode = prev.nextNode, next = removingNode.nextNode;        Element element = removingNode.element;        prev.nextNode = next;        size--;        return element;    }    @Override    public int indexOf( Object o ){        int i = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ return i; }            i++;        }        return -1;    }    @Override    public int lastIndexOf( Object o ){        int i = -1, k = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ i = k; }            k++;        }        return i;    }    private class Node implements Serializable{        Element element;        Node nextNode;        Node( Element element , Node nextNode ){            this.element = element;            this.nextNode = nextNode;        }    }    @Override    public int hashCode(){        return Arrays.hashCode( this.toArray() );    }    @Override    public boolean equals( Object obj ){        if( !( obj instanceof OneSideLinkedCycleList ) ){ return false; }        OneSideLinkedCycleList list = ( OneSideLinkedCycleList ) obj;        return Arrays.equals( this.toArray() , list.toArray() );    }    @Override    public boolean remove( Object o ){        throw new UnsupportedOperationException();    }    @Override    public boolean containsAll( Collection<?> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean addAll( Collection<? extends Element> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean addAll( int index , Collection<? extends Element> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean removeAll( Collection<?> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean retainAll( Collection<?> c ){        throw new UnsupportedOperationException();    }    @Override    public ListIterator<Element> listIterator(){        throw new UnsupportedOperationException();    }    @Override    public ListIterator<Element> listIterator( int index ){        throw new UnsupportedOperationException();    }    @Override    public List<Element> subList( int fromIndex , int toIndex ){        throw new UnsupportedOperationException();    }}