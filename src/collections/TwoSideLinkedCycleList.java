package collections;import java.io.Serializable;import java.util.*;import java.util.function.BiPredicate;public class TwoSideLinkedCycleList<Element> implements List<Element>, Serializable, Cloneable{    private Node    head;    private Integer size;    public TwoSideLinkedCycleList( List<Element> list ){        if( !list.isEmpty() ){            head = linkList( list , null );            lastNode.nextNode = head;            head.previousNode = lastNode;        }        size = list.size();    }    private Node lastNode;    private Node linkList( List<Element> list , Node prev ){        if( list.size() == 1 ){            lastNode = new Node( list.get( 0 ) , prev , null );            return lastNode;        }        Node node = new Node( list.get( 0 ) , prev , null );        node.nextNode = linkList( list.subList( 1 , list.size() ) , node );        return node;    }    @Override    public int size(){        return size;    }    @Override    public boolean isEmpty(){        return size == 0;    }    @Override    public boolean contains( Object o ){        return indexOf( 0 ) != -1;    }    @Override    public Iterator<Element> iterator(){        return new Iterator<>(){            Node goingNode = head;            Integer goingIndex = 0;            @Override            public boolean hasNext(){                return goingIndex < size;            }            @Override            public Element next(){                Element element = goingNode.element;                goingNode = goingNode.nextNode;                goingIndex++;                return element;            }        };    }    @Override    public Object[] toArray(){        Object[] result = new Object[ size ];        int      i      = 0;        for( Element element : this ){ result[ i++ ] = element; }        return Arrays.copyOf( result , result.length );    }    @Override    public <T> T[] toArray( T[] result ){        if( result.length < size ){            result = ( T[] ) java.lang.reflect.Array.newInstance( result.getClass().getComponentType() , size );        }        int i = 0;        for( Element element : this ){ result[ i++ ] = ( T ) element; }        i++;        for( ; i < result.length ; i++ ){ result[ i ] = null; }        return Arrays.copyOf( result , result.length );    }    private Node getNode( int offset ){        if( isEmpty() ){ throw new IllegalStateException( "List is empty" ); }        Node goingNode = head;        offset = Math.abs( offset ) % size <= size / 2 ? offset % size :                 offset % size - ( offset / Math.abs( offset ) ) * size;        for( int i = 0 ; i < Math.abs( offset ) ; i++ )            goingNode = offset >= 0 ? goingNode.nextNode : goingNode.previousNode;        return goingNode;    }    @Override    public boolean add( Element element ){        add( size - 1 , element );        return true;    }    @Override    public void clear(){        head = null;        size = 0;    }    @Override    public Element get( int index ){        return getNode( index ).element;    }    @Override    public Element set( int index , Element element ){        Node    node       = getNode( index );        Element resElement = node.element;        node.element = element;        return resElement;    }    @Override    public void add( int index , Element element ){        if( isEmpty() ){            head = new Node( element , null , null );            head.previousNode = head.nextNode = head;        }else{            Node prevNode = getNode( index - 1 ), nextNode = prevNode.nextNode;            prevNode.nextNode = new Node( element , prevNode , nextNode );            nextNode.previousNode = prevNode.nextNode;        }        size++;    }    @Override    public Element remove( int index ){        Node prevNode = getNode( index - 1 ), removingNode = prevNode.nextNode, nextNode = removingNode.nextNode;        prevNode.nextNode = nextNode;        nextNode.previousNode = prevNode;        size--;        return removingNode.element;    }    @Override    public int indexOf( Object o ){        int i = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ return i; }            i++;        }        return -1;    }    @Override    public int lastIndexOf( Object o ){        int i = size - 1;        for( Node goingNode = head.previousNode ; i >= 0 ; i-- , goingNode = goingNode.previousNode )            if( goingNode.element == null ? o == null : goingNode.element.equals( o ) ){ return i; }        return -1;    }    @Override    public int hashCode(){        return Arrays.hashCode( this.toArray() );    }    @Override    public boolean equals( Object obj ){        if( !( obj instanceof TwoSideLinkedCycleList ) ){ return false; }        TwoSideLinkedCycleList list = ( TwoSideLinkedCycleList ) obj;        return Arrays.equals( this.toArray() , list.toArray() );    }    @Override    public Object clone() throws CloneNotSupportedException{        TwoSideLinkedCycleList<Element> clone = ( TwoSideLinkedCycleList<Element> ) super.clone();        clone.size = size;        if( !isEmpty() ){            clone.head = clone.linkList( this , null );            clone.head.previousNode = clone.lastNode;            clone.lastNode.nextNode = clone.head;        }        return clone;    }    private class Node implements Serializable{        Element element;        Node previousNode;        Node nextNode;        Node( Element element , Node previousNode , Node nextNode ){            this.element = element;            this.previousNode = previousNode;            this.nextNode = nextNode;        }    }    @Override    public List<Element> subList( int fromIndex , int toIndex ){        throw new UnsupportedOperationException();    }    @Override    public boolean remove( Object o ){        Node prev = getNode( -1 ), going = prev.nextNode;        for( int i = 0 ; i < size ; i++ , prev = going , going = going.nextNode ){            if( going.element == null ? o == null : going.element.equals( o ) ){                prev.nextNode = going.nextNode;                size--;                return true;            }        }        return false;    }    @Override    public boolean containsAll( Collection<?> collection ){        for( Object o : collection ){ if( !this.contains( o ) ){ return false; } }        return true;    }    @Override    public boolean addAll( Collection<? extends Element> collection ){        return addAll( size , collection );    }    @Override    public boolean addAll( int index , Collection<? extends Element> collection ){        if( collection.isEmpty() ){ return false; }        Node headOfAddingList = linkList( new ArrayList<>( collection ) , null );        Node prevNode         = getNode( index - 1 ), nextNode = prevNode.nextNode;        prevNode.nextNode = headOfAddingList;        headOfAddingList.previousNode = prevNode;        lastNode.nextNode = nextNode;        nextNode.previousNode = lastNode;        size += collection.size();        return true;    }    private boolean removeAllWithPredicate( BiPredicate<Element, Object> predicate , Collection<?> collection ){        Node    prev, going, next;        Boolean res = false;        for( Object o : collection ){            prev = getNode( -1 );            going = prev.nextNode;            next = going.nextNode;            for( int i = 0 ; i < size ; i++ , prev = going , going = next , next = next.nextNode ){                if( predicate.test( going.element , o ) ){                    res = true;                    prev.nextNode = next;                    going = next;                    next = next.nextNode;                    size--;                }            }        }        return res;    }    @Override    public boolean removeAll( Collection<?> collection ){        return removeAllWithPredicate( ( element , o ) -> element == null ? o == null : element.equals( o ) ,                                       collection );    }    @Override    public boolean retainAll( Collection<?> collection ){        return removeAllWithPredicate( ( element , o ) -> !element.equals( o ) , collection );    }    @Override    public ListIterator<Element> listIterator(){        throw new UnsupportedOperationException();    }    @Override    public ListIterator<Element> listIterator( int index ){        throw new UnsupportedOperationException();    }}