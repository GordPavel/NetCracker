package collections;import java.io.Serializable;import java.util.*;public class TwoSideLinkedCycleList<Element> implements List<Element>, Serializable{    private Node    head;    private Integer size;    public TwoSideLinkedCycleList( List<Element> list ){        if( !list.isEmpty() ){            head = linkList( list , null );            last.nextNode = head;            head.previousNode = last;        }        size = list.size();    }    private Node last;    private Node linkList( List<Element> list , Node prev ){        if( list.size() == 1 ){            last = new Node( list.get( 0 ) , prev , null );            return last;        }        Node node = new Node( list.get( 0 ) , prev , null );        node.nextNode = linkList( list.subList( 1 , list.size() ) , node );        return node;    }    @Override    public int size(){        return size;    }    @Override    public boolean isEmpty(){        return size == 0;    }    @Override    public boolean contains( Object o ){        return indexOf( 0 ) != -1;    }    @Override    public Iterator<Element> iterator(){        return new Iterator<>(){            Node goingNode = head;            Integer goingIndex = 0;            @Override            public boolean hasNext(){                return goingIndex < size;            }            @Override            public Element next(){                Element element = goingNode.element;                goingNode = goingNode.nextNode;                goingIndex++;                return element;            }        };    }    @Override    public Object[] toArray(){        Object[] result = new Object[ size ];        int      i      = 0;        for( Element element : this ){ result[ i++ ] = element; }        return result;    }    @Override    public <T> T[] toArray( T[] a ){        if( a.length < size ){            a = ( T[] ) java.lang.reflect.Array.newInstance( a.getClass().getComponentType() , size );        }        int i = 0;        for( Element element : this ){ a[ i++ ] = ( T ) element; }        i++;        for( ; i < a.length ; i++ ){ a[ i ] = null; }        return a;    }    private Node getNode( int offset ){        if( isEmpty() ){ throw new IllegalStateException( "List is empty" ); }        Node goingNode = head;        offset = Math.abs( offset ) % size <= size / 2 ? offset % size :                 offset % size - ( offset / Math.abs( offset ) ) * size;        for( int i = 0 ; i < Math.abs( offset ) ; i++ ){            goingNode = offset >= 0 ? goingNode.nextNode : goingNode.previousNode;        }        return goingNode;    }    @Override    public boolean add( Element element ){        add( size - 1 , element );        return true;    }    @Override    public void clear(){        head = null;        size = 0;    }    @Override    public Element get( int index ){        return getNode( index ).element;    }    @Override    public Element set( int index , Element element ){        Node    node       = getNode( index );        Element resElement = node.element;        node.element = element;        return resElement;    }    @Override    public void add( int index , Element element ){        if( isEmpty() ){            head = new Node( element , null , null );            head.previousNode = head.nextNode = head;        }else{            Node prevNode = getNode( index - 1 ), nextNode = prevNode.nextNode;            prevNode.nextNode = new Node( element , prevNode , nextNode );            nextNode.previousNode = prevNode.nextNode;        }        size++;    }    @Override    public Element remove( int index ){        Node prevNode = getNode( index - 1 ), removingNode = prevNode.nextNode, nextNode = removingNode.nextNode;        prevNode.nextNode = nextNode;        nextNode.previousNode = prevNode;        size--;        return removingNode.element;    }    @Override    public int indexOf( Object o ){        int i = 0;        for( Element element : this ){            if( element == null ? o == null : element.equals( o ) ){ return i; }            i++;        }        return -1;    }    @Override    public int lastIndexOf( Object o ){        int i = size - 1;        for( Node goingNode = head.previousNode ; i >= 0 ; i-- , goingNode = goingNode.previousNode ){            if( goingNode.element == null ? o == null : goingNode.element.equals( o ) ){ return i; }        }        return -1;    }    @Override    public int hashCode(){        return Arrays.hashCode( this.toArray() );    }    @Override    public boolean equals( Object obj ){        if( !( obj instanceof TwoSideLinkedCycleList ) ){ return false; }        TwoSideLinkedCycleList list = ( TwoSideLinkedCycleList ) obj;        return Arrays.equals( this.toArray() , list.toArray() );    }    private class Node implements Serializable{        Element element;        Node previousNode;        Node nextNode;        Node( Element element , Node previousNode , Node nextNode ){            this.element = element;            this.previousNode = previousNode;            this.nextNode = nextNode;        }    }    @Override    public ListIterator<Element> listIterator(){        throw new UnsupportedOperationException();    }    @Override    public ListIterator<Element> listIterator( int index ){        throw new UnsupportedOperationException();    }    @Override    public List<Element> subList( int fromIndex , int toIndex ){        throw new UnsupportedOperationException();    }    @Override    public boolean remove( Object o ){        throw new UnsupportedOperationException();    }    @Override    public boolean containsAll( Collection<?> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean addAll( Collection<? extends Element> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean addAll( int index , Collection<? extends Element> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean removeAll( Collection<?> c ){        throw new UnsupportedOperationException();    }    @Override    public boolean retainAll( Collection<?> c ){        throw new UnsupportedOperationException();    }}